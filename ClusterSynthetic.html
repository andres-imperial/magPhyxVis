<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cluster Synthetic</title>
    <style>
        .root {
            display: grid;
        }
        .header {
            grid-row: 1;
        }

        .table {
            margin: 20px;
            grid-row: 3;
            text-align: center;
            margin-top: 30;
            table-layout: fixed;
        }
        .content {
            grid-row: 2;
            left: 50%;
            top: 50%;
            width: 80vw;
            height: 30vh;
            padding-bottom: 50px;
            margin-bottom: 50px;
        }

        .v100{
          background-color: red;
        }

        table, td {
          table-layout: fixed;
          width: 20px;
          border: solid 1px;
          border-collapse: collapse;
          text-align: center;
          font-size: x-small;
        }

        svg {
            width: 75%;
            right: 0;
            align-self: right;
        }

        header button {
            padding: 10px 20px;
        }

        img {
            width: 100px;
            height: 100px;
            padding-right: 20px;
            padding-bottom: 20px;
        }
    </style>
</head>
<body>
<div id="root">
    <header class="header">
    </header>
    <div class="content">
        <svg width="100%" height="100%">

        </svg>
    </div>
    <svg id="scatter_points"></svg>
    <svg id="scatter_values"></svg>
    <svg id="scatter_area"></svg>
    <svg id="clusters"></svg>
</div>

<script src="d3.js"></script>
<script src="math.js"></script>
<script src="js/clustering.js"></script>
  <script>
    function plotData(data, selectTag = null, title = 'default', xAxis = 'default', yAxis = 'default') {
      let svgWidth = 1000;
      let svgHeight = 800;
      let margin = 100;
      let width = svgWidth - 2 * margin;
      let height = svgHeight - 2 * margin;
      let xAxisLabel = xAxis;
      let yAxisLabel = yAxis;
      let titleLabel = title;
      if (selectTag == null)
      {
        selectTag = 'svg#scatter_area';
      }

      let svg = d3.select(selectTag)
          .attr('width', svgWidth)
          .attr('height', svgHeight);
      let barChart = svg.append('g')
        .attr('transform', `translate(${margin}, ${margin})`);
      let yScale = d3.scaleLinear().range([ height, 0 ]).domain([
        Math.floor(Math.min(...data.map(d => d.y))),
        Math.ceil(Math.max(...data.map(d => d.y)))
      ]);
      let xScale = d3.scaleLinear()
        .range([0, width])
        .domain([0, Math.ceil(Math.max(...data.map(d => d.x)))]);

      barChart.append('g')
        .style('font-size', '10px')
        .call(d3.axisLeft(yScale));

      barChart.append('g')
        .attr('transform', `translate(0, ${height})`)
        .style('font-size', '12px')
        .call(d3.axisBottom(xScale).tickFormat(d3.format("d")));

      svg.selectAll("circle")
        .data(data)
        .enter()
        .append('circle')
        .attr("cx", d => xScale(d.x) + margin)
        .attr("cy", d => yScale(d.y) + margin)
        .attr("r", 5)
        .attr("fill", d => d.color);

      svg.append('text')
        .attr('x', -(height / 2) - margin)
        .attr('y', margin / 2.8)
        .attr('transform', 'rotate(-90)')
        .attr('text-anchor', 'middle')
        .style('font-size', '20px')
        .text(yAxisLabel)

      svg.append('text')
        .attr('x', width / 2 + margin)
        .attr('y', height + margin + 40)
        .attr('text-anchor', 'middle')
        .style('font-size', '20px')
        .text(xAxisLabel)

      svg.append('text')
        .attr('x', width / 2 + margin)
        .attr('y', 40)
        .attr('text-anchor', 'middle')
        .style('font-size', '30px')
        .text(titleLabel)
    }

    function plotData2(data)
    {
      // set the dimensions and margins of the graph
      var margin = {top: 10, right: 40, bottom: 30, left: 30},
          width = 450 - margin.left - margin.right,
          height = 400 - margin.top - margin.bottom;

      // append the svg object to the body of the page
      var svG = d3.select("#scatter_area")
        .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

      // X scale and Axis
      var x = d3.scaleLinear()
          .domain([0, 400])         // This is the min and the max of the data: 0 to 100 if percentages
          .range([0, width]);       // This is the corresponding value I want in Pixel
      svG
        .append('g')
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

      // X scale and Axis
      var y = d3.scaleLinear()
          .domain([0, 400])         // This is the min and the max of the data: 0 to 100 if percentages
          .range([height, 0]);       // This is the corresponding value I want in Pixel
      svG
        .append('g')
        .call(d3.axisLeft(y));

      // Add 3 dots for 0, 50 and 100%
      svG.selectAll("whatever")
          .data(data)
          .enter()
          .append("circle")
          .attr("cx", function(d){return x(d.x)})
          .attr("cy", function(d){return y(d.y)})
          .attr("r", 7)
          .style("fill", function(d){return d.color})
    }

    function calculateEuclids(a, b)
    {
      let xDelta = a.x - b.x;
      let yDelta = a.y - b.y;

      let distSquared = xDelta * xDelta + yDelta * yDelta;
      return Math.sqrt(distSquared);
    }

    function generateSyntheticData(){
      let clusterOrigins = [ [ 25, 25 ], [ 50, 50 ], [5, 50]];
      let offset = 10;
      let data = [];
      let NUMPOINTS = 10;

      for (let origin of clusterOrigins)
      {
        for (var i = 0; i < NUMPOINTS; ++i)
        {
          let rand = Math.random();
          randXOffset = rand * offset;
          rand = Math.random();
          randYOffset = rand * offset;
          randPoint = {
            "x" : origin[0] + randXOffset,
            "y" : origin[1] + randYOffset
          };
          data.push(randPoint);
        }
      }

      return data;
    }

    function cluster_synthetic()
    {
      data = generateSyntheticData();
      distFunc = calculateEuclids;

      <!-- let kMeansClusters = -->
      <!--     kMeansClustering(data, 3, 50, distFunc); -->
      let clusters = newSpectralClustering(data, 3, distFunc);

      return;

      data = [];

      for (var i = 0; i < kMeansClusters.clusters.length; ++i) {
        var customColorScale = [
          'grey', 'orange', 'red', 'brown', 'blue', 'purple', 'green', 'pink',
          'yellow', 'grey', 'orange', 'red', 'brown', 'blue', 'purple', 'green',
          'pink', 'yellow', 'black'
        ];

        kMeansClusters.clusters[i].forEach(function(d) {
          if (kMeansClusters.clusterOrigins.some(o => o.x ==
                                                      d.x && o.y == d.y)) {
            d.color = customColorScale[customColorScale.length - 1];
          } else {
            d.color = customColorScale[i];
          }
        });

        data = data.concat(kMeansClusters.clusters[i]);
      }

      console.log(data);
      plotData(data);

      return data;
    }

    cluster_synthetic();
  </script>
</body>
</html>

